namespace lesson04_封装_构造函数和析构函数
{
    #region 1.构造函数
    //基本概念
    //再实例化对象时，会调用的用于初始化的函数
    //如果不写，默认存在一个无参构造函数

    //构造函数的写法
    //1.没有返回值
    //2.函数名和类名必须相同
    //3.没有特殊需求时，一般都是public的
    //4.构造函数可以被重载
    //5.this代表当前调用该函数的对象自己

    /// <summary>
    /// 人类
    /// </summary>
    class Person
    {
        /// <summary>
        /// 名字
        /// </summary>
        public string name;
        /// <summary>
        /// 年龄
        /// </summary>
        public int age;

        //类中是允许自己申明无参构造函数的
        //结构体是不允许
        public Person()
        {
            name = "味精";
            age = 18;
        }

        public Person(int age)
        {
            this.age = age;
        }

        public Person(string name)
        {
            this.name = name;
        }

        public Person(int age, string name) : this()
        {
            Console.WriteLine("Person两个参数构造函数调用");
        }

        //当引用类型的堆内存被回收时
        //析构函数，是当垃圾真正被回收的时候，才会调用的函数
        ~Person()
        {

        }
    }
    //注意：
    //如果不自己实现无参构造函数而实现了有参构造函数
    //会失去默认的无参构造
    #endregion

    #region 2.构造函数特殊写法
    //可以通过this，重用构造函数代码
    //访问修饰符 构造函数名(参数列表) : this(参数1,参数2.....)
    #endregion

    #region 3.析构函数
    //基本概念
    //当引用类型的堆内存被回收时，会调用该函数
    //对于需要手动管理内存的语言（比如C++），需要在析构函数中做一些内存回收处理
    //但是C#中存在自动回收垃圾机制GC
    //所以我们几乎不会怎么使用析构函数，除非你想在某一个对象被垃圾回收时，做一些特殊处理
    //注意：
    //在Unity开发中析构函数几乎不会使用，使用该知识点只做了解即可

    //基本语法
    //~类名()
    //{

    //}

    #endregion

    #region 4.垃圾回收机制
    //垃圾回收，英文简称GC（Garbage Collector）
    //垃圾回收的过程是在遍历堆（Heap）上动态分配的所有对象
    //通过识别他们是否被引用来确定哪些对象是垃圾，哪些对象仍要被使用
    //所谓的垃圾就是灭有被任何变量，对象引用的内容
    //垃圾就需要被回收释放

    //垃圾回收有很多种算法，比如
    //引用计数（Referebce Counting）
    //标记清除（Mark Sweep）
    //标记整理（Mark Compact）
    //复制集合（Copy Collection）

    //注意：
    //GC只负责堆（Heap）内存的垃圾回收
    //引用类型都是存在堆（Heap）中的，所以他的分配和释放都通过垃圾回收机制来管理

    //栈（Stack）上的内存是由系统自动管理的
    //值类型在栈（Stack）中分配内存的，他们有自己的生命周期，不用对他们进行管理，会自动分配和释放

    //C#中内存回收机制的大概原理
    //0代内存  1代内存    2代内存
    //代的概念：
    //代是垃圾回收机制使用的一种算法（分代算法）
    //新分配的对象都会被配置在第0代内存中
    //每次分配都可能会进行垃圾回收以释放内存（0代内存满时）

    //在依次内存回收过程开始时，垃圾回收器会认为堆中全是垃圾，会进行以下两步
    //1.标记对象，从根（静态字段、方法参数）开始检查引用对象，标记后为可达对象，未标记为不可达对象，不可达对象就是认为是垃圾
    //2.搬迁对象压缩堆（挂起执行托管代码线程）释放未标记的对象 搬迁可达对象，修改引用地址

    //大对象总被认为是第二代内存，目的是减少性能损耗，提高性能
    //不会对大对象进行搬迁压缩，95000字节（83KB）以上的对象为大对象
    #endregion
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("构造函数和析构函数");

            //string name = "味精";
            Person player = new Person(27, "味精");
            Console.WriteLine($"{player.name}");

            //手动触发垃圾回收的方法
            //都是在Loading过场景 才调用
            GC.Collect();

            //总结
            //构造函数
            //实例化对象时，调用的函数
            //主要是用来初始化成员变量的

            //基本语法
            //不写返回值
            //函数名和类名相同
            //访问修饰符根据需求而定
            //一般为pulic

            //注意
            //可以重载构造函数
            //可以用this语法重用代码
            //可以在函数中有this区分同名参数和成员变量

            //析构函数
            //当对象被垃圾回收时调用的，主要是用来回收资源或者特殊处理内存的

            //基本语法
            //不写返回值
            //不写修饰符
            //不能有参数
            //函数名和类型相同
            //前面加~
        }
    }
}
